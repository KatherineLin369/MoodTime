# Create a new directory mkdir moodtime cd moodtime # Initialize Node.js project npm init -y # Install all dependencies (from package.json below) npm install mkdir -p client/src/{pages,components,hooks,lib} mkdir -p server/{replit_integrations,replit_integrations/auth,replit_integrations/chat,replit_integrations/image} mkdir -p shared/models mkdir -p migrations mkdir -p attached_assets { "name": "rest-express", "version": "1.0.0", "type": "module", "license": "MIT", "scripts": { "dev": "NODE_ENV=development tsx server/index.ts", "build": "tsx script/build.ts", "start": "NODE_ENV=production node dist/index.cjs", "check": "tsc", "db:push": "drizzle-kit push" }, "dependencies": { "@hookform/resolvers": "^3.10.0", "@radix-ui/react-accordion": "^1.2.4", "@radix-ui/react-alert-dialog": "^1.1.7", "@radix-ui/react-aspect-ratio": "^1.1.3", "@radix-ui/react-avatar": "^1.1.4", "@radix-ui/react-checkbox": "^1.1.5", "@radix-ui/react-collapsible": "^1.1.4", "@radix-ui/react-context-menu": "^2.2.7", "@radix-ui/react-dialog": "^1.1.7", "@radix-ui/react-dropdown-menu": "^2.1.7", "@radix-ui/react-hover-card": "^1.1.7", "@radix-ui/react-label": "^2.1.3", "@radix-ui/react-menubar": "^1.1.7", "@radix-ui/react-navigation-menu": "^1.2.6", "@radix-ui/react-popover": "^1.1.7", "@radix-ui/react-progress": "^1.1.3", "@radix-ui/react-radio-group": "^1.2.4", "@radix-ui/react-scroll-area": "^1.2.4", "@radix-ui/react-select": "^2.1.7", "@radix-ui/react-separator": "^1.1.3", "@radix-ui/react-slider": "^1.2.4", "@radix-ui/react-slot": "^1.2.0", "@radix-ui/react-switch": "^1.1.4", "@radix-ui/react-tabs": "^1.1.4", "@radix-ui/react-toast": "^1.2.7", "@radix-ui/react-toggle": "^1.1.3", "@radix-ui/react-toggle-group": "^1.1.3", "@radix-ui/react-tooltip": "^1.2.0", "@tanstack/react-query": "^5.60.5", "@types/memoizee": "^0.4.12", "class-variance-authority": "^0.7.1", "clsx": "^2.1.1", "cmdk": "^1.1.1", "connect-pg-simple": "^10.0.0", "date-fns": "^3.6.0", "drizzle-orm": "^0.39.3", "drizzle-zod": "^0.7.1", "embla-carousel-react": "^8.6.0", "express": "^4.21.2", "express-session": "^1.18.2", "framer-motion": "^11.18.2", "input-otp": "^1.4.2", "lucide-react": "^0.453.0", "memoizee": "^0.4.17", "memorystore": "^1.6.7", "next-themes": "^0.4.6", "openai": "^6.15.0", "openid-client": "^6.8.1", "p-limit": "^7.2.0", "p-retry": "^7.1.1", "passport": "^0.7.0", "passport-local": "^1.0.0", "pg": "^8.16.3", "react": "^18.3.1", "react-day-picker": "^8.10.1", "react-dom": "^18.3.1", "react-hook-form": "^7.55.0", "react-icons": "^5.4.0", "react-resizable-panels": "^2.1.7", "recharts": "^2.15.4", "tailwind-merge": "^2.6.0", "tailwindcss-animate": "^1.0.7", "tw-animate-css": "^1.2.5", "vaul": "^1.1.2", "wouter": "^3.3.5", "ws": "^8.18.0", "zod": "^3.25.76", "zod-validation-error": "^3.5.4" }, "devDependencies": { "@tailwindcss/typography": "^0.5.15", "@tailwindcss/vite": "^4.1.18", "@types/connect-pg-simple": "^7.0.3", "@types/express": "4.17.21", "@types/express-session": "^1.18.2", "@types/node": "20.19.27", "@types/passport": "^1.0.17", "@types/passport-local": "^1.0.38", "@types/react": "^18.3.11", "@types/react-dom": "^18.3.1", "@types/ws": "^8.5.13", "@vitejs/plugin-react": "^4.7.0", "autoprefixer": "^10.4.20", "drizzle-kit": "^0.31.8", "esbuild": "^0.25.0", "postcss": "^8.4.47", "tailwindcss": "^3.4.17", "tsx": "^4.20.5", "typescript": "5.6.3", "vite": "^7.3.0" } } { "include": ["client/src/**/*", "shared/**/*", "server/**/*"], "exclude": ["node_modules", "build", "dist", "**/*.test.ts"], "compilerOptions": { "incremental": true, "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo", "noEmit": true, "module": "ESNext", "strict": true, "lib": ["esnext", "dom", "dom.iterable"], "jsx": "preserve", "esModuleInterop": true, "skipLibCheck": true, "allowImportingTsExtensions": true, "moduleResolution": "bundler", "baseUrl": ".", "types": ["node", "vite/client"], "paths": { "@/*": ["./client/src/*"], "@shared/*": ["./shared/*"] } } } import type { Config } from "tailwindcss"; export default { darkMode: ["class"], content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"], theme: { extend: { borderRadius: { lg: ".5625rem", md: ".375rem", sm: ".1875rem", }, colors: { background: "hsl(var(--background) / )", foreground: "hsl(var(--foreground) / )", border: "hsl(var(--border) / )", input: "hsl(var(--input) / )", card: { DEFAULT: "hsl(var(--card) / )", foreground: "hsl(var(--card-foreground) / )", border: "hsl(var(--card-border) / )", }, popover: { DEFAULT: "hsl(var(--popover) / )", foreground: "hsl(var(--popover-foreground) / )", border: "hsl(var(--popover-border) / )", }, primary: { DEFAULT: "hsl(var(--primary) / )", foreground: "hsl(var(--primary-foreground) / )", border: "var(--primary-border)", }, secondary: { DEFAULT: "hsl(var(--secondary) / )", foreground: "hsl(var(--secondary-foreground) / )", border: "var(--secondary-border)", }, muted: { DEFAULT: "hsl(var(--muted) / )", foreground: "hsl(var(--muted-foreground) / )", border: "var(--muted-border)", }, accent: { DEFAULT: "hsl(var(--accent) / )", foreground: "hsl(var(--accent-foreground) / )", border: "var(--accent-border)", }, destructive: { DEFAULT: "hsl(var(--destructive) / )", foreground: "hsl(var(--destructive-foreground) / )", border: "var(--destructive-border)", }, ring: "hsl(var(--ring) / )", }, fontFamily: { sans: ["var(--font-sans)"], serif: ["var(--font-serif)"], mono: ["var(--font-mono)"], display: ["var(--font-display)"], body: ["var(--font-body)"], }, }, }, plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")], } satisfies Config; import { defineConfig } from "vite"; import react from "@vitejs/plugin-react"; import path from "path"; export default defineConfig({ plugins: [react()], resolve: { alias: { "@": path.resolve(__dirname, "client", "src"), "@shared": path.resolve(__dirname, "shared"), "@assets": path.resolve(__dirname, "attached_assets"), }, }, root: path.resolve(__dirname, "client"), build: { outDir: path.resolve(__dirname, "dist/public"), emptyOutDir: true, }, server: { fs: { strict: true, deny: ["**/.*"], }, }, }); import { defineConfig } from "drizzle-kit"; if (!process.env.DATABASE_URL) { throw new Error("DATABASE_URL, ensure the database is provisioned"); } export default defineConfig({ out: "./migrations", schema: "./shared/schema.ts", dialect: "postgresql", dbCredentials: { url: process.env.DATABASE_URL, }, }); export default { plugins: { tailwindcss: {}, autoprefixer: {}, }, }
@import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&family=Nunito+Sans:wght@300;400;600;700&display=swap'); @tailwind base; @tailwind components; @tailwind utilities; :root { /* Mental Wellness Palette - Yellow, Green, Blue */ --primary: 200 80% 55%; --primary-foreground: 0 0% 100%; --secondary: 85 70% 60%; --secondary-foreground: 85 30% 25%; --accent: 45 95% 55%; --accent-foreground: 45 50% 30%; --background: 50 100% 97%; --foreground: 200 20% 25%; --card: 0 0% 100%; --card-foreground: 200 20% 25%; --muted: 200 30% 94%; --muted-foreground: 200 15% 55%; --border: 200 30% 90%; --input: 200 30% 90%; --ring: 200 80% 55%; --destructive: 0 70% 65%; --destructive-foreground: 0 0% 98%; --radius: 1.5rem; --font-display: 'Quicksand', sans-serif; --font-body: 'Nunito Sans', sans-serif; } @layer base { body { @apply bg-background text-foreground antialiased font-body selection:bg-accent/30; background-image: radial-gradient(circle at 10% 20%, rgba(100, 200, 255, 0.3) 0%, transparent 25%), radial-gradient(circle at 90% 80%, rgba(200, 255, 100, 0.3) 0%, transparent 25%); background-attachment: fixed; } h1, h2, h3, h4, h5, h6 { @apply font-display font-bold tracking-tight text-slate-700; } } @layer utilities { .text-balance { text-wrap: balance; } .glass-card { @apply bg-white/70 backdrop-blur-lg border border-white/50 shadow-[0_8px_30px_rgb(0,0,0,0.04)]; } .glass-panel { @apply bg-white/40 backdrop-blur-md border border-white/30; } .no-scrollbar::-webkit-scrollbar { display: none; } .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; } } .slide-up { animation: slideUp 0.5s ease-out forwards; } @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } } export * from "./models/auth"; export * from "./models/chat"; import { pgTable, text, serial, integer, timestamp } from "drizzle-orm/pg-core"; import { createInsertSchema } from "drizzle-zod"; import { z } from "zod"; export const moodEntries = pgTable("mood_entries", { id: serial("id").primaryKey(), userId: text("user_id").notNull(), value: integer("value").notNull(), emotions: text("emotions").array().notNull().default([]), note: text("note"), createdAt: timestamp("created_at").defaultNow(), }); export const insertMoodEntrySchema = createInsertSchema(moodEntries).omit({ id: true, createdAt: true }); export type InsertMoodEntry = z.infer; export type MoodEntry = typeof moodEntries.$inferSelect; import { sql } from "drizzle-orm"; import { index, jsonb, pgTable, timestamp, varchar } from "drizzle-orm/pg-core"; export const sessions = pgTable( "sessions", { sid: varchar("sid").primaryKey(), sess: jsonb("sess").notNull(), expire: timestamp("expire").notNull(), }, (table) => [index("IDX_session_expire").on(table.expire)] ); export const users = pgTable("users", { id: varchar("id").primaryKey().default(sql`gen_random_uuid()`), email: varchar("email").unique(), firstName: varchar("first_name"), lastName: varchar("last_name"), profileImageUrl: varchar("profile_image_url"), createdAt: timestamp("created_at").defaultNow(), updatedAt: timestamp("updated_at").defaultNow(), }); export type UpsertUser = typeof users.$inferInsert; export type User = typeof users.$inferSelect; import { pgTable, serial, integer, text, timestamp } from "drizzle-orm/pg-core"; import { createInsertSchema } from "drizzle-zod"; import { z } from "zod"; import { sql } from "drizzle-orm"; export const conversations = pgTable("conversations", { id: serial("id").primaryKey(), userId: text("user_id"), title: text("title").notNull(), createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(), }); export const messages = pgTable("messages", { id: serial("id").primaryKey(), conversationId: integer("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }), role: text("role").notNull(), content: text("content").notNull(), createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(), }); export const insertConversationSchema = createInsertSchema(conversations).omit({ id: true, createdAt: true, }); export const insertMessageSchema = createInsertSchema(messages).omit({ id: true, createdAt: true, }); export type Conversation = typeof conversations.$inferSelect; export type InsertConversation = z.infer; export type Message = typeof messages.$inferSelect; export type InsertMessage = z.infer; import { z } from 'zod'; import { insertMoodEntrySchema, moodEntries } from './schema'; export const errorSchemas = { validation: z.object({ message: z.string(), field: z.string().optional(), }), notFound: z.object({ message: z.string(), }), internal: z.object({ message: z.string(), }), }; export const api = { moods: { list: { method: 'GET' as const, path: '/api/moods', responses: { 200: z.array(z.custom()), }, }, create: { method: 'POST' as const, path: '/api/moods', input: insertMoodEntrySchema, responses: { 201: z.custom(), 400: errorSchemas.validation, }, }, }, }; export function buildUrl(path: string, params?: Record): string { let url = path; if (params) { Object.entries(params).forEach(([key, value]) => { if (url.includes(`:${key}`)) { url = url.replace(`:${key}`, String(value)); } }); } return url; } import express, { type Request, Response, NextFunction } from "express"; import { registerRoutes } from "./routes"; import { serveStatic } from "./static"; import { createServer } from "http"; const app = express(); const httpServer = createServer(app); declare module "http" { interface IncomingMessage { rawBody: unknown; } } app.use( express.json({ verify: (req, _res, buf) => { req.rawBody = buf; }, }), ); app.use(express.urlencoded({ extended: false })); export function log(message: string, source = "express") { const formattedTime = new Date().toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit", second: "2-digit", hour12: true, }); console.log(`${formattedTime} [${source}] ${message}`); } app.use((req, res, next) => { const start = Date.now(); const path = req.path; let capturedJsonResponse: Record | undefined = undefined; const originalResJson = res.json; res.json = function (bodyJson, ...args) { capturedJsonResponse = bodyJson; return originalResJson.apply(res, [bodyJson, ...args]); }; res.on("finish", () => { const duration = Date.now() - start; if (path.startsWith("/api")) { let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`; if (capturedJsonResponse) { logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`; } log(logLine); } }); next(); }); (async () => { await registerRoutes(httpServer, app); app.use((err: any, _req: Request, res: Response, _next: NextFunction) => { const status = err.status || err.statusCode || 500; const message = err.message || "Internal Server Error"; res.status(status).json({ message }); throw err; }); if (process.env.NODE_ENV === "production") { serveStatic(app); } else { const { setupVite } = await import("./vite"); await setupVite(httpServer, app); } const port = parseInt(process.env.PORT || "5000", 10); httpServer.listen( { port, host: "0.0.0.0", reusePort: true, }, () => { log(`serving on port ${port}`); }, ); })(); import { drizzle } from "drizzle-orm/node-postgres"; import pg from "pg"; import * as schema from "@shared/schema"; const { Pool } = pg; if (!process.env.DATABASE_URL) { throw new Error( "DATABASE_URL must be set. Did you forget to provision a database?", ); } export const pool = new Pool({ connectionString: process.env.DATABASE_URL }); export const db = drizzle(pool, { schema }); import { moodEntries, type MoodEntry, type InsertMoodEntry } from "@shared/schema"; import { db } from "./db"; import { eq, desc } from "drizzle-orm"; export interface IStorage { createMoodEntry(entry: InsertMoodEntry): Promise; getMoodEntries(userId: string): Promise; } export class DatabaseStorage implements IStorage { async createMoodEntry(entry: InsertMoodEntry): Promise { const [mood] = await db .insert(moodEntries) .values(entry) .returning(); return mood; } async getMoodEntries(userId: string): Promise { return await db .select() .from(moodEntries) .where(eq(moodEntries.userId, userId)) .orderBy(desc(moodEntries.createdAt)); } } export const storage = new DatabaseStorage(); import express, { type Express } from "express"; import fs from "fs"; import path from "path"; export function serveStatic(app: Express) { const distPath = path.resolve(__dirname, "public"); if (!fs.existsSync(distPath)) { throw new Error( `Could not find the build directory: ${distPath}, make sure to build the client first`, ); } app.use(express.static(distPath)); // fall through to index.html if the file doesn't exist app.use("*", (_req, res) => { res.sendFile(path.resolve(distPath, "index.html")); }); } import type { Express } from "express"; import { createServer, type Server } from "http"; import { storage } from "./storage"; import { setupAuth, registerAuthRoutes } from "./replit_integrations/auth"; import { registerChatRoutes } from "./replit_integrations/chat"; import { registerImageRoutes } from "./replit_integrations/image"; import { api } from "@shared/routes"; import { z } from "zod"; import { isAuthenticated } from "./replit_integrations/auth"; export async function registerRoutes( httpServer: Server, app: Express ): Promise { // 1. Setup Auth (Must be first) await setupAuth(app); registerAuthRoutes(app); // 2. Setup Integrations registerChatRoutes(app); registerImageRoutes(app); // 3. Application Routes // Mood Entries - Protected app.get(api.moods.list.path, isAuthenticated, async (req: any, res) => { const userId = req.user.claims.sub; const moods = await storage.getMoodEntries(userId); res.json(moods); }); app.post(api.moods.create.path, isAuthenticated, async (req: any, res) => { try { const input = api.moods.create.input.parse(req.body); const mood = await storage.createMoodEntry({ ...input, userId: req.user.claims.sub }); res.status(201).json(mood); } catch (err) { if (err instanceof z.ZodError) { return res.status(400).json({ message: err.errors[0].message, field: err.errors[0].path.join('.'), }); } throw err; } }); return httpServer; } import { createRoot } from "react-dom/client"; import App from "./App"; import "./index.css"; createRoot(document.getElementById("root")!).render(); import { Switch, Route, useLocation } from "wouter"; import { queryClient } from "./lib/queryClient"; import { QueryClientProvider } from "@tanstack/react-query"; import { Toaster } from "@/components/ui/toaster"; import { TooltipProvider } from "@/components/ui/tooltip"; import { useAuth } from "@/hooks/use-auth"; import { Sidebar, MobileHeader } from "@/components/Navigation"; import { Loader2 } from "lucide-react"; // Pages import Landing from "@/pages/Landing"; import Home from "@/pages/Home"; import MoodJournal from "@/pages/MoodJournal"; import AIChat from "@/pages/AIChat"; import Games from "@/pages/Games"; import Resources from "@/pages/Resources"; import Profile from "@/pages/Profile"; import NotFound from "@/pages/not-found"; function ProtectedRoute({ component: Component }: { component: React.ComponentType }) { const { isAuthenticated, isLoading } = useAuth(); if (isLoading) { return (
); } if (!isAuthenticated) { return ; } return (
); } function Router() { const { isAuthenticated, isLoading } = useAuth(); const [location] = useLocation(); if (isLoading) return null; // Public route if (!isAuthenticated) { return ( ); } // Protected routes return ( } /> } /> } /> } /> } /> } /> } /> ); } function App() { return ( ); } export default App; import { QueryClient, QueryFunction } from "@tanstack/react-query"; async function throwIfResNotOk(res: Response) { if (!res.ok) { const text = (await res.text()) || res.statusText; throw new Error(`${res.status}: ${text}`); } } export async function apiRequest( method: string, url: string, data?: unknown | undefined, ): Promise { const res = await fetch(url, { method, headers: data ? { "Content-Type": "application/json" } : {}, body: data ? JSON.stringify(data) : undefined, credentials: "include", }); await throwIfResNotOk(res); return res; } type UnauthorizedBehavior = "returnNull" | "throw"; export const getQueryFn: (options: { on401: UnauthorizedBehavior; }) => QueryFunction = ({ on401: unauthorizedBehavior }) => async ({ queryKey }) => { const res = await fetch(queryKey.join("/") as string, { credentials: "include", }); if (unauthorizedBehavior === "returnNull" && res.status === 401) { return null; } await throwIfResNotOk(res); return await res.json(); }; export const queryClient = new QueryClient({ defaultOptions: { queries: { queryFn: getQueryFn({ on401: "throw" }), refetchInterval: false, refetchOnWindowFocus: false, staleTime: Infinity, retry: false, }, mutations: { retry: false, }, }, }); export function isUnauthorizedError(error: Error): boolean { return /^401: .*Unauthorized/.test(error.message); } export function redirectToLogin(toast?: (options: { title: string; description: string; variant: string }) => void) { if (toast) { toast({ title: "Unauthorized", description: "You are logged out. Logging in again...", variant: "destructive", }); } setTimeout(() => { window.location.href = "/api/login"; }, 500); } import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"; import type { User } from "@shared/models/auth"; async function fetchUser(): Promise { const response = await fetch("/api/auth/user", { credentials: "include", }); if (response.status === 401) { return null; } if (!response.ok) { throw new Error(`${response.status}: ${response.statusText}`); } return response.json(); } async function logout(): Promise { window.location.href = "/api/logout"; } export function useAuth() { const queryClient = useQueryClient(); const { data: user, isLoading } = useQuery({ queryKey: ["/api/auth/user"], queryFn: fetchUser, retry: false, staleTime: 1000 * 60 * 5, }); const logoutMutation = useMutation({ mutationFn: logout, onSuccess: () => { queryClient.setQueryData(["/api/auth/user"], null); }, }); return { user, isLoading, isAuthenticated: !!user, logout: logoutMutation.mutate, isLoggingOut: logoutMutation.isPending, }; } import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"; import { z } from "zod"; const moodSchema = z.object({ id: z.number(), value: z.number().min(1).max(5), emotions: z.array(z.string()), note: z.string().optional(), createdAt: z.string().or(z.date()).pipe(z.coerce.date()), userId: z.string().optional(), }); export type Mood = z.infer; export type CreateMoodInput = { value: number; emotions: string[]; note?: string; }; const API_BASE = "/api/moods"; export function useMoods() { return useQuery({ queryKey: [API_BASE], queryFn: async () => { try { const res = await fetch(API_BASE, { credentials: "include" }); if (!res.ok) { if (res.status === 404) return []; throw new Error("Failed to fetch moods"); } const data = await res.json(); return z.array(moodSchema).parse(data); } catch (err) { console.warn("Using empty moods list", err); return []; } }, }); } export function useCreateMood() { const queryClient = useQueryClient(); return useMutation({ mutationFn: async (data: CreateMoodInput) => { const res = await fetch(API_BASE, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(data), credentials: "include", }); if (!res.ok) throw new Error("Failed to create mood entry"); return moodSchema.parse(await res.json()); }, onSuccess: () => { queryClient.invalidateQueries({ queryKey: [API_BASE] }); }, }); } DATABASE_URL=your_postgresql_connection_string OPENAI_API_KEY=your_openai_key SESSION_SECRET=random_secret_key npm run build npm start npm run db:push